#!/usr/bin/env python3
import os
import requests
import json
import random
import string
import sys
from typing import Dict, Any, Optional, Union, Tuple, List
from dotenv import load_dotenv

class APIClient:
    def __init__(self, base_url: Optional[str] = None, token: Optional[str] = None):
        """
        Initialize the API client.
        
        Args:
            base_url: Base URL for the API (will use URL env var if not provided)
            token: Authentication token (will use TOKEN env var if not provided)
        """
        if base_url is None or token is None:
            load_dotenv()
            
        self.base_url = base_url or os.getenv('URL')
        self.token = token or os.getenv('TOKEN')
        
        if not self.base_url:
            raise ValueError("API URL is required. Set URL environment variable or pass base_url")
        
        if not self.token:
            raise ValueError("API token is required. Set TOKEN environment variable or pass token")
        
        if not self.base_url.endswith('/'):
            self.base_url += '/'
            
        self.users_endpoint = f"{self.base_url}api/v1/users/"
        
        self.headers = {
            'accept': 'application/json',
            'Authorization': self.token
        }
    
    def get_users(self) -> List[Dict[str, Any]]:
        """Get all users from the API"""
        try:
            response = requests.get(self.users_endpoint, headers=self.headers)
            response.raise_for_status()
            
            try:
                return response.json()
            except json.JSONDecodeError:
                return response.text
        except requests.exceptions.RequestException as e:
            print(f"Error fetching users: {e}", file=sys.stderr)
            return None
    
    def get_user(self, username: str) -> Dict[str, Any]:
        """Get a specific user by username"""
        try:
            user_url = f"{self.users_endpoint}{username}"
            response = requests.get(user_url, headers=self.headers)
            response.raise_for_status()
            
            try:
                return response.json()
            except json.JSONDecodeError:
                return response.text
        except requests.exceptions.RequestException as e:
            print(f"Error fetching user {username}: {e}", file=sys.stderr)
            return None
    
    def add_user(self, username: str, traffic_limit: int, expiration_days: int, 
                 password: Optional[str] = None, creation_date: Optional[str] = None) -> Tuple[bool, str]:
        """
        Add a new user via the API
        
        Args:
            username: Username for the new user
            traffic_limit: Traffic limit in GB
            expiration_days: Number of days until expiration
            password: Optional password (will be generated by API if not provided)
            creation_date: Optional creation date (will use current date if not provided)
            
        Returns:
            Tuple of (success: bool, message: str)
        """
        data = {
            "username": username,
            "traffic_limit": traffic_limit,
            "expiration_days": expiration_days
        }
        
        # Add optional parameters if provided
        if password:
            data["password"] = password
        if creation_date:
            data["creation_date"] = creation_date
        
        post_headers = self.headers.copy()
        post_headers['Content-Type'] = 'application/json'
        
        try:
            response = requests.post(
                self.users_endpoint, 
                headers=post_headers, 
                json=data
            )
            
            if response.status_code >= 200 and response.status_code < 300:
                try:
                    result = response.json()
                    return True, f"User {username} added successfully."
                except json.JSONDecodeError:
                    return True, response.text
            else:
                try:
                    error_data = response.json()
                    error_message = error_data.get('detail', response.text)
                    return False, f"Error: {error_message}"
                except json.JSONDecodeError:
                    return False, f"Error: {response.text}"
                
        except requests.exceptions.RequestException as e:
            return False, f"Error adding user: {str(e)}"

    def edit_user(self, username: str, new_username: Optional[str] = None, 
                  new_traffic_limit: Optional[int] = None, new_expiration_days: Optional[int] = None,
                  renew_password: bool = False, renew_creation_date: bool = False, 
                  blocked: Optional[bool] = None) -> Tuple[bool, str]:
        """
        Edit an existing user via the API
        
        Args:
            username: Current username of the user to edit
            new_username: Optional new username
            new_traffic_limit: Optional new traffic limit in GB
            new_expiration_days: Optional new expiration days
            renew_password: Whether to generate a new password
            renew_creation_date: Whether to reset the creation date
            blocked: Optional blocked status
            
        Returns:
            Tuple of (success: bool, message: str)
        """
        data = {}
        
        if new_username:
            data["new_username"] = new_username
        if new_traffic_limit is not None:
            data["traffic_limit"] = new_traffic_limit
        if new_expiration_days is not None:
            data["expiration_days"] = new_expiration_days
        if renew_password:
            data["renew_password"] = True
        if renew_creation_date:
            data["renew_creation_date"] = True
        if blocked is not None:
            data["blocked"] = blocked
        
        if not data:
            return False, "Error: No changes specified"
        
        patch_headers = self.headers.copy()
        patch_headers['Content-Type'] = 'application/json'
        
        try:
            response = requests.patch(
                f"{self.users_endpoint}{username}", 
                headers=patch_headers, 
                json=data
            )
            
            if response.status_code >= 200 and response.status_code < 300:
                try:
                    result = response.json()
                    return True, f"User {username} updated successfully."
                except json.JSONDecodeError:
                    return True, response.text
            else:
                try:
                    error_data = response.json()
                    error_message = error_data.get('detail', response.text)
                    return False, f"Error: {error_message}"
                except json.JSONDecodeError:
                    return False, f"Error: {response.text}"
                
        except requests.exceptions.RequestException as e:
            return False, f"Error updating user: {str(e)}"

    def reset_user(self, username: str) -> Tuple[bool, str]:
        """
        Reset a user (traffic usage) via the API
        
        Args:
            username: Username of the user to reset
            
        Returns:
            Tuple of (success: bool, message: str)
        """
        try:
            response = requests.post(
                f"{self.users_endpoint}{username}/reset", 
                headers=self.headers
            )
            
            if response.status_code >= 200 and response.status_code < 300:
                return True, f"User {username} reset successfully."
            else:
                try:
                    error_data = response.json()
                    error_message = error_data.get('detail', response.text)
                    return False, f"Error: {error_message}"
                except json.JSONDecodeError:
                    return False, f"Error: {response.text}"
                
        except requests.exceptions.RequestException as e:
            return False, f"Error resetting user: {str(e)}"

    def remove_user(self, username: str) -> Tuple[bool, str]:
        """
        Remove a user via the API
        
        Args:
            username: Username of the user to remove
            
        Returns:
            Tuple of (success: bool, message: str)
        """
        try:
            response = requests.delete(
                f"{self.users_endpoint}{username}", 
                headers=self.headers
            )
            
            if response.status_code >= 200 and response.status_code < 300:
                return True, f"User {username} removed successfully."
            else:
                try:
                    error_data = response.json()
                    error_message = error_data.get('detail', response.text)
                    return False, f"Error: {error_message}"
                except json.JSONDecodeError:
                    return False, f"Error: {response.text}"
                
        except requests.exceptions.RequestException as e:
            return False, f"Error removing user: {str(e)}"
            
    def restart_server(self) -> Tuple[bool, str]:
        """
        Restart the dijiq server via the API
        
        Returns:
            Tuple of (success: bool, message: str)
        """
        try:
            response = requests.post(
                f"{self.base_url}api/v1/server/restart", 
                headers=self.headers
            )
            
            if response.status_code >= 200 and response.status_code < 300:
                return True, "dijiq server restarted successfully."
            else:
                try:
                    error_data = response.json()
                    error_message = error_data.get('detail', response.text)
                    return False, f"Error: {error_message}"
                except json.JSONDecodeError:
                    return False, f"Error: {response.text}"
                
        except requests.exceptions.RequestException as e:
            return False, f"Error restarting server: {str(e)}"

def generate_random_username(length=8):
    """Generate a random username of specified length"""
    characters = string.ascii_lowercase + string.digits
    return ''.join(random.choice(characters) for _ in range(length))


if __name__ == "__main__":
    # This allows the module to be run directly for testing
    client = APIClient()
    users = client.get_users()
    print(json.dumps(users, indent=2))